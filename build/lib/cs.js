"use strict";class CSG{constructor(){this.polygons=[]}clone(){var a=new CSG;return a.polygons=this.polygons.map(function(a){return a.clone()}),a}toPolygons(){return this.polygons}union(c){var d=new Node(this.clone().polygons),a=new Node(c.clone().polygons);return d.clipTo(a),a.clipTo(d),a.invert(),a.clipTo(d),a.invert(),d.build(a.allPolygons()),CSG.fromPolygons(d.allPolygons())}subtract(c){var d=new Node(this.clone().polygons),a=new Node(c.clone().polygons);return d.invert(),d.clipTo(a),a.clipTo(d),a.invert(),a.clipTo(d),a.invert(),d.build(a.allPolygons()),d.invert(),CSG.fromPolygons(d.allPolygons())}intersect(c){var d=new Node(this.clone().polygons),a=new Node(c.clone().polygons);return d.invert(),a.clipTo(d),a.invert(),d.clipTo(a),a.clipTo(d),d.build(a.allPolygons()),d.invert(),CSG.fromPolygons(d.allPolygons())}inverse(){var a=this.clone();return a.polygons.map(function(a){a.flip()}),a}}CSG.fromPolygons=function(a){var b=new CSG;return b.polygons=a,b};class Vector extends THREE.Vector3{constructor(a,b,c){if(3==arguments.length)super(a,b,c);else if(Array.isArray(a))super(a[0],a[1],a[2]);else if("object"==typeof a)super().copy(a);else throw"Invalid constructor to vector"}clone(){return new Vector(this)}negated(){return this.clone().multiplyScalar(-1)}plus(b){return this.clone().add(b)}minus(b){return this.clone().sub(b)}times(b){return this.clone().multiplyScalar(b)}dividedBy(b){return this.clone().divideScalar(b)}lerp(b,a){return this.plus(b.minus(this).times(a))}unit(){return this.dividedBy(this.length())}cross(b){return THREE.Vector3.prototype.cross.call(this.clone(),b)}}class Vertex{constructor(a,b,c){this.pos=new Vector(a),this.normal=new Vector(b),this.uv=new Vector(c)}clone(){return new Vertex(this.pos.clone(),this.normal.clone(),this.uv.clone())}flip(){this.normal=this.normal.negated()}interpolate(a,b){return new Vertex(this.pos.lerp(a.pos,b),this.normal.lerp(a.normal,b),this.uv.lerp(a.uv,b))}}class Plane{constructor(a,b){this.normal=a,this.w=b}clone(){return new Plane(this.normal.clone(),this.w)}flip(){this.normal=this.normal.negated(),this.w=-this.w}splitPolygon(a,c,d,e,g){for(var h=0,k=1,l=2,m=3,n=0,o=[],p=0;p<a.vertices.length;p++){var q=this.normal.dot(a.vertices[p].pos)-this.w,r=q<-Plane.EPSILON?l:q>Plane.EPSILON?k:h;n|=r,o.push(r)}switch(n){case h:(0<this.normal.dot(a.plane.normal)?c:d).push(a);break;case k:e.push(a);break;case l:g.push(a);break;case m:for(var s=[],f=[],p=0;p<a.vertices.length;p++){var b=(p+1)%a.vertices.length,j=o[p],u=o[b],w=a.vertices[p],x=a.vertices[b];if(j!=l&&s.push(w),j!=k&&f.push(j==l?w:w.clone()),(j|u)==m){var q=(this.w-this.normal.dot(w.pos))/this.normal.dot(x.pos.minus(w.pos)),y=w.interpolate(x,q);s.push(y),f.push(y.clone())}}3<=s.length&&e.push(new Polygon(s,a.shared)),3<=f.length&&g.push(new Polygon(f,a.shared));}}}Plane.EPSILON=1e-5,Plane.fromPoints=function(d,a,b){var c=a.minus(d).cross(b.minus(d)).unit();return new Plane(c,c.dot(d))};class Polygon{constructor(a,b){this.vertices=a,this.shared=b,this.plane=Plane.fromPoints(a[0].pos,a[1].pos,a[2].pos)}clone(){var a=this.vertices.map(function(a){return a.clone()});return new Polygon(a,this.shared)}flip(){this.vertices.reverse().map(function(a){a.flip()}),this.plane.flip()}}class Node{constructor(a){this.plane=null,this.front=null,this.back=null,this.polygons=[],a&&this.build(a)}clone(){var a=new Node;return a.plane=this.plane&&this.plane.clone(),a.front=this.front&&this.front.clone(),a.back=this.back&&this.back.clone(),a.polygons=this.polygons.map(function(a){return a.clone()}),a}invert(){for(var a=0;a<this.polygons.length;a++)this.polygons[a].flip();this.plane.flip(),this.front&&this.front.invert(),this.back&&this.back.invert();var b=this.front;this.front=this.back,this.back=b}clipPolygons(a){if(!this.plane)return a.slice();for(var b=[],c=[],d=0;d<a.length;d++)this.plane.splitPolygon(a[d],b,c,b,c);return this.front&&(b=this.front.clipPolygons(b)),c=this.back?this.back.clipPolygons(c):[],b.concat(c)}clipTo(a){this.polygons=a.clipPolygons(this.polygons),this.front&&this.front.clipTo(a),this.back&&this.back.clipTo(a)}allPolygons(){var a=this.polygons.slice();return this.front&&(a=a.concat(this.front.allPolygons())),this.back&&(a=a.concat(this.back.allPolygons())),a}build(a){if(a.length){this.plane||(this.plane=a[0].plane.clone());for(var b=[],c=[],d=0;d<a.length;d++)this.plane.splitPolygon(a[d],this.polygons,this.polygons,b,c);b.length&&(!this.front&&(this.front=new Node),this.front.build(b)),c.length&&(!this.back&&(this.back=new Node),this.back.build(c))}}}CSG.fromGeometry=function(a){a.isBufferGeometry&&(a=new THREE.Geometry().fromBufferGeometry(a));for(var b=a.faces,c=a.vertices,d=[],e=["a","b","c"],g=0;g<b.length;g++){for(var h=b[g],f=[],k=0;3>k;k++)f.push(new Vertex(c[h[e[k]]],h.vertexNormals[k],a.faceVertexUvs[0][g][k]));d.push(new Polygon(f))}return CSG.fromPolygons(d)},CSG._tmpm3=new THREE.Matrix3,CSG.fromMesh=function(a){var b=CSG.fromGeometry(a.geometry);CSG._tmpm3.getNormalMatrix(a.matrix);for(var c,d=0;d<b.polygons.length;d++){c=b.polygons[d];for(var e,f=0;f<c.vertices.length;f++)e=c.vertices[f],e.pos.applyMatrix4(a.matrix),e.normal.applyMatrix3(CSG._tmpm3)}return b},CSG.toMesh=function(a,b){for(var c=new THREE.Geometry,d=a.polygons,e=c.vertices,f=c.faceVertexUvs[0],g=0;g<d.length;g++){for(var h=d[g],k=h.vertices,l=e.length,n=k.length,o=0;o<n;o++)e.push(new THREE.Vector3().copy(k[o].pos));for(var o=3;o<=n;o++){var p=new THREE.Face3,q=[];f.push(q);var r=p.vertexNormals;p.a=l,p.b=l+o-2,p.c=l+o-1,r.push(new THREE.Vector3().copy(k[0].normal)),r.push(new THREE.Vector3().copy(k[o-2].normal)),r.push(new THREE.Vector3().copy(k[o-1].normal)),q.push(new THREE.Vector3().copy(k[0].uv)),q.push(new THREE.Vector3().copy(k[o-2].uv)),q.push(new THREE.Vector3().copy(k[o-1].uv)),p.normal=new THREE.Vector3().copy(h.plane.normal),c.faces.push(p)}}var s=new THREE.Matrix4().getInverse(b);c.applyMatrix4(s),c.verticesNeedUpdate=c.elementsNeedUpdate=c.normalsNeedUpdate=!0,c.computeBoundingSphere(),c.computeBoundingBox();var t=new THREE.Mesh(c);return t.matrix.copy(b),t.matrix.decompose(t.position,t.rotation,t.scale),t.updateMatrixWorld(),t},CSG.ieval=function(a,b=0){if("string"==typeof a)CSG.currentOp=a;else if(a instanceof Array)for(let b=0;b<a.length;b++)CSG.ieval(a[b],0);else if("object"==typeof a){var c=CSG.currentOp;a.updateMatrix(),a.updateMatrixWorld(),CSG.sourceMesh?(CSG.nextPrim=CSG.fromMesh(a),CSG.currentPrim=CSG.currentPrim[c](CSG.nextPrim)):CSG.currentPrim=CSG.fromMesh(CSG.sourceMesh=a),CSG.doRemove&&a.parent.remove(a)}},CSG.eval=function(a,b){CSG.currentOp=null,CSG.sourceMesh=null,CSG.doRemove=b,CSG.ieval(a);var c=CSG.toMesh(CSG.currentPrim,CSG.sourceMesh.matrix);return c.material=CSG.sourceMesh.material,c.castShadow=c.receiveShadow=!0,c};export default CSG;